#!/usr/bin/env python
#
# gandi-dyndns - Dynamic DNS script for Gandi.net users
#
# Copyright (C) 2012 Adam Sutton <dev@adamsutton.me.uk>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#

#
# Imports
#

import os, sys, re
import xmlrpclib, urllib2
from optparse import OptionParser

#
# Api wrapper
#
class GandiAPI:

    # Setup
    def __init__ ( self, key, domain ):
        self._rpc = xmlrpclib.ServerProxy('https://rpc.gandi.net/xmlrpc/')
        self._key = key
        self._domain = domain
        self._zoneid = None
        self._zonever = None

        # Check key/domain
        if not self.apikey_check():
            print 'ERROR: apikey specified [%s] was invalid' % key
            sys.exit(1)

        #if not self.domain_check():
        #    print 'ERROR: domain specified [%s] was invalid' % domain
        #    sys.exit(1)

        try:
            di = self.domain_info()
            if 'zone_id' in di:
                self._zoneid = di['zone_id']
            else:
                print 'ERROR: zone id for domain [%s] could not be found' % domain
                sys.exit(1)
        except Exception, e:
            print 'ERROR: apikey/domain specified [%s] was invalid' % domain
            sys.exit(1)

    # API version
    def version ( self ):
        return self._rpc.version.info(self._key)

    def apikey_check( self ):
        try:
            self.version()
            return True
        except xmlrpclib.Fault as err:
            return False

    # Domain info
    def domain_info ( self ):
        return self._rpc.domain.info(self._key, self._domain)

    def domain_check ( self ):
        try:
            self.domain_info()
            return True
        except xmlrpclib.Fault as err:
            return False

    def zone_list( self ):
        return self._rpc.domain.zone.list(self._key)

    # Get zone record
    def zone_record_list ( self, name = None, type = None ):
        opts = {}
        if name: opts['name'] = name
        if type: opts['type'] = type
        return self._rpc.domain.zone.record.list(self._key, self._zoneid, 0, opts)

    def zone_record_check ( self, name, type, external_ip ):
        records = self.zone_record_list(name, type)
        if len(records) > 0:
            for record in records:
                if record['value'] == external_ip:
                    return False

        return True

    # Get new zone version
    def zone_version_new ( self ):
        return self._rpc.domain.zone.version.new(self._key, self._zoneid)

    # Delete a zone record
    def zone_record_delete ( self, zver, name, type ):
        opts = { 'name' : name, 'type' : type }
        self._rpc.domain.zone.record.delete(self._key, self._zoneid, zver, opts)

    # Insert a new record
    def zone_record_insert ( self, zver, name, type, value, ttl ):
        opts = { 'name' : name, 'type' : type, 'value' : value, 'ttl' : ttl }
        self._rpc.domain.zone.record.add(self._key, self._zoneid, zver, opts)
        
    # Update a record
    def zone_record_update ( self, zver, name, type, value, ttl ):
        self.zone_record_delete(zver, name, type)
        self.zone_record_insert(zver, name, type, value, ttl)
        
    def zone_get_id ( self ):
        return self.domain_info()['zone_id']

    # Set active version
    def zone_version_set ( self, zver ):
        if zver:
            self._rpc.domain.zone.version.set(self._key, self._zoneid, zver)

#
# Get public IP address
#

def get_public_ipv4():
    try:
        return urllib2.urlopen('http://ipinfo.io/ip').read()
    except:
        print 'WARN: failed to retrieve IPv4 from http://ipinfo.io/ip'
    try:
        return urllib2.urlopen('http://api.externalip.net/ip/').read()
    except:
        print 'WARN: failed to retrieve IPv4 from http://api.externalip.net/ip/'
    try:
        data = urllib2.urlopen('http://checkip.dyndns.com/').read()
        matches = re.search('<body>Current IP Address: (.*?)</body>', data)
        if matches:
            return matches.group(1)
    except:
        print 'WARN: failed to retrieve IPv4 from http://checkip.dyndns.com/'
    return None

def get_public_ipv6():
    try:
        data = urllib2.urlopen("http://icanhazipv6.com").read()
        matches = re.search('<p class="my_address">(.*?)</p>', data)
        if matches:
            return matches.group(1)
    except:
        print 'WARN: failed to retrieve IPv4 from http://icanhazipv6.com'
    return None

def get_public_ipv4_orange():
    try:
        data = urllib2.urlopen("http://livebox/").read()
        
        # Livebox v2 Sagem
        matches = re.search('Adresse IP WAN :</td>[\s]+<td class="value">(.*?)</td>', data)
        if matches:
            return matches.group(1)
    except: pass

    print 'WARN: failed to retrieve IPv4 from http://livebox/'
    return get_public_ipv4()

#
# Main
#

if __name__ == '__main__':
    apikey = ''
    domain = ''
    record = ''
    provider = ''
    rtypes = []
    quiet = False
    test = False

    # Process command line
    optp = OptionParser()
    optp.add_option('-a', '--api', help='Specify API key')
    optp.add_option('-d', '--domain', help='Specify domain')
    optp.add_option('-r', '--record', help='Specify record data')
    optp.add_option('-t', '--ttl', help='Specify record TTL. Defaults to 300s (5min)',
            type='int', default=300)
    optp.add_option('-4', '--ipv4', help='Enable IPv4',
            action='store_true')
    optp.add_option('-6', '--ipv6', help='Enable IPv6',
            action='store_true')
    optp.add_option('-p', '--provider', help='Specify your Internet provider name to retrieve faster your IP adress (supported: orange)')
    optp.add_option('--test', help='Run test, do not update anything',
            action='store_true')
    optp.add_option('--extip4', help='Force external IPv4. This can be used to update a record with an IP different than the IP of the server/workstation from which the script is executed')
    optp.add_option('--extip6', help='Force external IPv6. This can be used to update a record with an IP different than the IP of the server/workstation from which the script is executed')
    optp.add_option('-q', '--quiet',    help='No output except to stderr on error', action='store_true')
    (opts, args) = optp.parse_args()

    # Validate Options
    if not opts.api or not opts.domain or not opts.record:
        print 'ERROR: you must specify -a -d and -r'
        sys.exit(1)

    # Process
    if opts.ipv4: rtypes.append('A')
    if opts.ipv6: rtypes.append('AAAA')
    domain = opts.domain
    apikey = opts.api
    record = opts.record
    ttl = opts.ttl
    provider = opts.provider
    extip4 = opts.extip4
    extip6 = opts.extip6
    if opts.test: test = True
    if opts.quiet: quiet = True

    # Setup api
    api = GandiAPI(apikey, domain)

    # Default
    if not rtypes:
        rtypes = ['A']

    # Test mode
    if opts.test:
        print 'INFO : running in test mode, will not update records'

    # Process records
    addresses = {}
    for rtype in rtypes:
        if api.zone_record_list(record, rtype) == False:
            print >> sys.stderr, (rtype + " Record " + record + " does not exist, please create")
            sys.exit(1)

        if rtype == 'A':
            if extip4:
                address = extip4
            else:
                if provider == 'orange':
                    address = get_public_ipv4_orange()
                else:
                    address = get_public_ipv4()
        elif rtype == 'AAAA':
            if extip6:
                address = extip6
            else:
                address = get_public_ipv6()
        if not address:
            print >> sys.stderr, ("Can't find address for record type '" + rtype + "'")
            sys.exit(1)
        addresses[rtype] = address
        
    # Fetch the active zone id
    zone_id = api.zone_get_id()
    
    # Check if the current IPv4 address changed
    for rtype in rtypes:
        ip_changed = api.zone_record_check(record, rtype, addresses[rtype])
        if not ip_changed:
            if not quiet:
                print ("INFO: The IP for '" + record + "' did not change")
            sys.exit(0)

    # Create a new zone version for zone id
    if test:
        zver = 12345
    else:
        zver = api.zone_version_new()

    if not quiet:
        print 'INFO : created a new zone file version %d' % zver

    for rtype in rtypes:
        # Update the record for the zone id and zone version
        if not test:
            api.zone_record_update(zver, record, rtype, addresses[rtype], ttl)
        if not quiet:
            print 'Updating record #'+record+':'
            print ' '+str(ttl)+' '+rtype+' '+addresses[rtype]

    # Activate the new zone
    if not test and zver:
        api.zone_version_set(zver)

    # Done
    print 'INFO: records updated'

# ###########################################################################
# Editor
#
# vim:sts=2:ts=2:sw=2:et
# ###########################################################################
